(setq lexical-binding t)

(defun load-input (file-path)
  (with-temp-buffer
    (insert-file-contents file-path)
    (buffer-string)))

(defun parse-input (input-string)
  (thread-last (split-string input-string ",")
    (mapcar 'string-to-number)))

(defun opcode-to-op (n)
  (cond ((= n 1) '+)
        ((= n 2) '*)
        ((= n 99) "finish")
        (t "bad")))

(defun parse-instruction (n)
  (let ((opcode (mod n 100))
        (m1 (mod (/ n 100) 10))
        (m2 (mod (/ n 1000) 10))
        (m3 (mod (/ n 10000) 10)))
    (list opcode m1 m2 m3)))

(defun program-to-table (program)
  (let ((table (make-hash-table))
        (i 0))
    (dolist (n program)
      (puthash i n table)
      (setq i (1+ i)))
    table))

(defun get-input ()
  (string-to-number (read-string "input pls: ")))

(defun get-val (position-mode index table)
  (if (not position-mode)
      (gethash index table)
    (gethash (gethash index table) table)))

(defun run (program input-fn output-fn)
  (let ((result nil)
        (table (program-to-table program))
        (i 0)
        (done nil))
    (while (not done)
      (let* ((instruction (parse-instruction (gethash i table)))
             (opcode (first instruction))
             (m1 (= (second instruction) 0))
             (m2 (= (third instruction) 0))
             (m3 (= (fourth instruction) 0)))
        (cond ((= opcode 1)
               (let* ((a (get-val m1 (1+ i) table))
                      (b (get-val m2 (+ 2 i) table))
                      (out (gethash (+ 3 i) table)))
                 (puthash out (+ a b) table))
               (setq i (+ 4 i)))
              ((= opcode 2)
               (let* ((a (get-val m1 (1+ i) table))
                      (b (get-val m2 (+ 2 i) table))
                      (out (gethash (+ 3 i) table)))
                 (puthash out (* a b) table))
               (setq i (+ 4 i)))
              ((= opcode 3)
               (let ((in (funcall input-fn))
                     (out (gethash (1+ i) table)))
                 (puthash out in table))
               (setq i (+ 2 i)))
              ((= opcode 4)
               (let ((v (get-val m1 (1+ i) table)))
                 (funcall output-fn v))
               (setq i (+ 2 i)))
              ((= opcode 5)
               (let ((param1 (get-val m1 (1+ i) table))
                     (param2 (get-val m2 (+ 2 i) table)))
                 (if (not (= param1 0))
                     (setq i param2)
                   (setq i (+ 3 i)))))
              ((= opcode 6)
               (let ((param1 (get-val m1 (1+ i) table))
                     (param2 (get-val m2 (+ 2 i) table)))
                 (if (= param1 0)
                     (setq i param2)
                   (setq i (+ 3 i)))))
              ((= opcode 7)
               (let ((param1 (get-val m1 (1+ i) table))
                     (param2 (get-val m2 (+ 2 i) table))
                     (param3 (gethash (+ 3 i) table)))
                 (if (< param1 param2)
                     (puthash param3 1 table)
                   (puthash param3 0 table))
                 (setq i (+ 4 i))))
              ((= opcode 8)
               (let ((param1 (get-val m1 (1+ i) table))
                     (param2 (get-val m2 (+ 2 i) table))
                     (param3 (gethash (+ 3 i) table)))
                 (if (= param1 param2)
                     (puthash param3 1 table)
                   (puthash param3 0 table))
                 (setq i (+ 4 i))))
              ((= opcode 99)
               (setq result (gethash 0 table))
               (setq done t)))))
    result))

(defun pair-input (a b)
  (let ((calls 0))
    (lambda ()
      (setq calls (1+ calls))
      (cond ((= calls 1) a)
            ((= calls 2) b)
            (t (error "called input too many times"))))))

(setq fn (pair-input 1 2))
(funcall fn)

(defun chain (program phase-setting)
  (let ((in-a 0)
        (in-b 0)
        (in-c 0)
        (in-d 0)
        (in-e 0)
        (out 0))
    (run program (pair-input (first phase-setting) in-a) (lambda (x) (setq in-b x)))
    (run program (pair-input (second phase-setting) in-b) (lambda (x) (setq in-c x)))
    (run program (pair-input (third phase-setting) in-c) (lambda (x) (setq in-d x)))
    (run program (pair-input (fourth phase-setting) in-d) (lambda (x) (setq in-e x)))
    (run program (pair-input (fifth phase-setting) in-e) (lambda (x) (setq out x)))
    out))

(chain (parse-input "3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0") '(4 3 2 1 0))

(chain (parse-input "3,23,3,24,1002,24,10,24,1002,23,-1,23,101,5,23,23,1,24,23,23,4,23,99,0,0")
       '(0 1 2 3 4))

(chain
 (parse-input
  "3,31,3,32,1002,32,10,32,1001,31,-2,31,1007,31,0,33,1002,33,7,33,1,33,31,31,1,32,31,31,4,31,99,0,0,0")
 '(1 0 4 3 2))

(setq puzzle-input (parse-input (load-input "input")))

(defun no-dups (l)
  (= (length l) (length (delete-dups l))))

(no-dups '(1 2 3 4 5))

(defun solve-day-7 (input)
  (let ((max 0))
    (dotimes (a 5)
      (dotimes (b 5)
        (dotimes (c 5)
          (dotimes (d 5)
            (dotimes (e 5)
              (let* ((phase-setting (list a b c d e))
                     (out (chain input phase-setting)))
                (when (and (no-dups phase-setting) (> out max))
                  (setq max out))))))))
    (print max)
    max))

(solve-day-7 (parse-input "3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0"))
(solve-day-7
 (parse-input
  "3,31,3,32,1002,32,10,32,1001,31,-2,31,1007,31,0,33,1002,33,7,33,1,33,31,31,1,32,31,31,4,31,99,0,0,0"))
(solve-day-7
 (parse-input
  "3,23,3,24,1002,24,10,24,1002,23,-1,23,101,5,23,23,1,24,23,23,4,23,99,0,0"))

(solve-day-7 (parse-input (load-input "input")))
